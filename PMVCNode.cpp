// parallelTransportFrame Plugin
// Initial code generated by Softimage SDK Wizard
// Executed Tue Aug 21 10:03:00 UTC+1000 2012 by ahmidoul
// 
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
#include <vector>
#include <xsi_application.h>
#include <xsi_context.h>
#include <xsi_pluginregistrar.h>
#include <xsi_status.h>

#include <xsi_icenodecontext.h>
#include <xsi_icenodedef.h>
#include <xsi_command.h>
#include <xsi_factory.h>
#include <xsi_longarray.h>
#include <xsi_doublearray.h>
#include <xsi_math.h>
#include <xsi_vector2f.h>
#include <xsi_vector3f.h>
#include <xsi_vector4f.h>
#include <xsi_matrix3f.h>
#include <xsi_matrix4f.h>
#include <xsi_rotationf.h>
#include <xsi_quaternionf.h>
#include <xsi_color4f.h>
#include <xsi_shape.h>
#include <xsi_icegeometry.h>
#include <xsi_iceportstate.h>
#include <xsi_indexset.h>
#include <xsi_dataarray.h>
#include <xsi_dataarray2D.h>

// Defines port, group and map identifiers used for registering the ICENode
enum IDs
{
	ID_IN_positionArray = 0,
	ID_IN_weightArray = 1,
	ID_IN_IDArray = 2,
	ID_G_100 = 100,
	ID_G_101 = 101,
	ID_OUT_positions = 200,
	ID_TYPE_CNS = 400,
	ID_STRUCT_CNS,
	ID_CTXT_CNS,
	ID_UNDEF = ULONG_MAX
};

XSI::CStatus RegisterparallelTransportFrame( XSI::PluginRegistrar& in_reg );

using namespace XSI; 


XSIPLUGINCALLBACK CStatus XSILoadPlugin( PluginRegistrar& in_reg )
{
	in_reg.PutAuthor(L"Ahmidou Lyazidi");
	in_reg.PutName(L"parallelTransportFrame Plugin");
	in_reg.PutVersion(1,0);

	RegisterparallelTransportFrame( in_reg );

	//RegistrationInsertionPoint - do not remove this line

	return CStatus::OK;
}

XSIPLUGINCALLBACK CStatus XSIUnloadPlugin( const PluginRegistrar& in_reg )
{
	CString strPluginName;
	strPluginName = in_reg.GetName();
	Application().LogMessage(strPluginName + L" has been unloaded.",siVerboseMsg);
	return CStatus::OK;
}

CStatus RegisterparallelTransportFrame( PluginRegistrar& in_reg )
{
	ICENodeDef nodeDef;
	nodeDef = Application().GetFactory().CreateICENodeDef(L"PMVC",L"PMVC");

	CStatus st;
	st = nodeDef.PutColor(40,100,146);
	st.AssertSucceeded( ) ;


	// Add input ports and groups.
	st = nodeDef.AddPortGroup(ID_G_100);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(ID_IN_positionArray,ID_G_100,siICENodeDataVector3,siICENodeStructureArray,siICENodeContextAny,L"positionArray",L"positionArray",MATH::CVector3f(1.0,1.0,1.0),CValue(),CValue(),ID_UNDEF,ID_UNDEF,ID_CTXT_CNS);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(ID_IN_weightArray,ID_G_100,siICENodeDataFloat,siICENodeStructureAny,siICENodeContextAny,L"weightArray",L"weightArray",float(1.0,1.0,1.0),CValue(),CValue(),ID_UNDEF,ID_UNDEF,ID_CTXT_CNS);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(ID_IN_IDArray,ID_G_100,siICENodeDataLong,siICENodeStructureAny,siICENodeContextAny,L"IDArray",L"IDArray",LONG(1.0,1.0,1.0),CValue(),CValue(),ID_UNDEF,ID_UNDEF,ID_CTXT_CNS);
	st.AssertSucceeded( ) ;

	// Add output ports.
	st = nodeDef.AddOutputPort(ID_OUT_positions,siICENodeDataVector3,siICENodeStructureArray,siICENodeContextAny,L"positions",L"positions",ID_UNDEF,ID_UNDEF,ID_CTXT_CNS);
	st.AssertSucceeded( ) ;

	PluginItem nodeItem = in_reg.RegisterICENode(nodeDef);
	nodeItem.PutCategories(L"Custom ICENode");

	return CStatus::OK;
}

struct CWeights
{
	CWeights() : nLen(0), pBuffer(NULL) {}
	~CWeights()
	{
		if (pBuffer)
			delete [] pBuffer;
	}

	LONG nLen;
	float* pBuffer;
};

XSIPLUGINCALLBACK CStatus parallelTransportFrame_BeginEvaluate( ICENodeContext& in_ctxt )
{
	CValue userData = in_ctxt.GetUserData( );
	if ( userData.IsEmpty() )
	{
		weightsData = new std::vector<CWeights>;
		in_ctxt.PutUserData( (CValue::siPtrType)weightsData );
	}
	else
	{
		// Reuse the user data buffer if already created.
		weightsData = (std::vector<CWeights>*)(CValue::siPtrType)in_ctxt.GetUserData( );
	}
	return CStatus::OK;
}

XSIPLUGINCALLBACK CStatus parallelTransportFrame_Term( ICENodeContext& in_ctxt )
{
	// Release memory allocated in BeginEvaluate
	CValue userData = in_ctxt.GetUserData( );
	if ( userData.IsEmpty() )
	{
		return CStatus::OK;
	}
	std::vector<CWeights>* weightsData = (std::vector<CWeights>*)(CValue::siPtrType)in_ctxt.GetUserData( );
	delete weightsData;

	// Clear user data
	in_ctxt.PutUserData( CValue() );

	return CStatus::OK;
}

XSIPLUGINCALLBACK CStatus parallelTransportFrame_Evaluate( ICENodeContext& in_ctxt )
{
	// The current output port being evaluated...
	ULONG out_portID = in_ctxt.GetEvaluatedOutputPortID( );
  
	switch( out_portID )
	{		
		case ID_OUT_positions :
		{
			CDataArray2DVector3f posArrayData( in_ctxt, ID_IN_positionArray );
			CDataArray2DFloat weightArrayData( in_ctxt, ID_IN_weightArray );

			// Get the output port array ...			
			CDataArray2DVector3f outData( in_ctxt );


 			// We need a CIndexSet to iterate over the data 		
			CIndexSet indexSet( in_ctxt );
			for(CIndexSet::Iterator it = indexSet.Begin(); it.HasNext(); it.Next())
			{
				// Add code to set output port...

				CDataArray2DVector3f::Accessor tangentArraySubArray = tangentArrayData[it];
				CDataArray2DVector3f::Accessor normalArraySubArray = normalArrayData[it];

				// Output arrays must always be initialized first
				CDataArray2DVector3f::Accessor outAccessor = outData.Resize( it, normalArraySubArray.GetCount( ) );
				for (ULONG i=0; i<tangentArraySubArray.GetCount( ); i++)
				{
					if(i == 0)
					{
						//prevTan.MulByMatrix3InPlace(initFrameData[it]);
						prevTan = tangentArraySubArray[i] ;
						prevNorm = normalArraySubArray[i] ;
					}
					else
					{
						prevTan = tangentArraySubArray[i-1] ;
						prevNorm = normalArraySubArray[i-1] ;
					}
					MATH::CVector3f axis ;
					axis.Cross(prevTan,tangentArraySubArray[i]);
					axis.NormalizeInPlace();
					float alpha = -(tangentArraySubArray[i].GetAngle(prevTan));

					/*matrixFromAxisAngle(axis,alpha,m1)*/
					float m[3][3];
					double x=axis.GetX();
					double y=axis.GetY();
					double z=axis.GetZ();

					double c = cos(alpha);
					double s = sin(alpha);
					double t = 1.0 - c;

					m[0][0] = c + x*x*t;
					m[1][1] = c + y*y*t;
					m[2][2] = c + z*z*t;

					double tmp1 = x*y*t;
					double tmp2 = z*s;
					m[1][0] = tmp1 + tmp2;
					m[0][1] = tmp1 - tmp2;
					tmp1 = x*z*t;
					tmp2 = y*s;
					m[2][0] = tmp1 - tmp2;
					m[0][2] = tmp1 + tmp2;
					tmp1 = y*z*t;
					tmp2 = x*s;
					m[2][1] = tmp1 + tmp2;
					m[1][2] = tmp1 - tmp2;

					m1.Set(m);
					prevNorm.MulByMatrix3InPlace(m1);
					normalArraySubArray[i] = prevNorm;
					outAccessor[i] = prevNorm;
				}
			}
		}
		break;
		
		// Other output ports...
	};
	
	return CStatus::OK;
}


void matrixFromAxisAngle(MATH::CVector3f a, float angle, MATH::CMatrix3f& m1)
{
	float m[3][3];
	double x=a.GetX();
	double y=a.GetY();
	double z=a.GetZ();
	double c = cos(angle);
	double s = sin(angle);
	double t = 1.0 - c;

	m[0][0] = c + x*x*t;
	m[1][1] = c + y*y*t;
	m[2][2] = c + z*z*t;

	double tmp1 = x*y*t;
	double tmp2 = z*s;
	m[1][0] = tmp1 + tmp2;
	m[0][1] = tmp1 - tmp2;
	tmp1 = x*z*t;
	tmp2 = y*s;
	m[2][0] = tmp1 - tmp2;
	m[0][2] = tmp1 + tmp2;
	tmp1 = y*z*t;
	tmp2 = x*s;
	m[2][1] = tmp1 + tmp2;
	m[1][2] = tmp1 - tmp2;

	m1.Set(m);
}
